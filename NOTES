# Mercenaries Archipelago

Notes on AP for Mercenaries: Playground of Destruction.

RA has achievements for "complete 3/6/9/12 missions for [faction]" which we can
base this on. There appear to be data structures for "what is the index of the
next mission for this faction".
- clear mission primary objective [is check]
  - money
  - reputation
  - MOM unlocks

RA has achievements for at least some and possibly all of these.
They're missable.
- clear mission bonus objective [missable]
  - money
  - reputation
  - MOM unlocks
  - if not completed, you have to reload an earlier save and retry

RA has leaderboards for these, which we can turn into checks for them.
- clear challenge
  - money

RA has counter achievements for these, the code is incredibly gnarly but I can
probably figure it out.
- find collectable [is check]
  - money per
  - reputation per
  - cheats at certain thresholds
  - MOM unlocks at certain thresholds
  - money at certain thresholds
  - might make each collectable a specific check, or might be easier to just
    count all collectables and unlock progressive checks

All cards are tracked in memory, RA has the addresses as alt conditions for the
"capture cards" achievements. These are spaced 0x28 bytes apart so it seems
likely that what we have here are arrays of card_t.
The status field for each card is a uint32_t and is 1 for "at large", 2 for "killed"
and 3 for "captured". 3 is set as soon as you get the mission complete popup, it
looks like; you only get the 2 next time you open the PDA.
- verify number card [missable]
  - money
  - intel
  - any that you haven't gotten before verifying the Ace will vanish when the
    Ace mission is completed
- verify face card
  - money
  - intel
  - MOM unlocks
  - always part of a mission
- verify Ace
  - money
  - intel
  - MOM unlocks
  - always part of a mission
  - this is a point of no return that vanishes all number cards of the same suit
    and spawns the next suit


Ideas for items in the pool:
- MOM unlocks (are these in lua? need to unlock MOM ingame to check)
  - maybe have cheats as separate pool items
- intel (hard -- where the fuck is this stored?)
- money (where is this???)
  - think I've found it: 1A77560; might also need to update 558BF0 or 558BF4 when wiggling it
  - might be dynamically allocated though :(
  - found it by verifying a card so that Player_UpdateMoney() gets called, then stepping
    through and watching the FPU registers until they converged on the final result, then
    jumping ahead dozens of instructions at a time while searching memory for that value
  - this is a float!
- reputation
  - RA has achievements for this (max/min reputation with all factions) that we can use

Intel and MOM unlocks are our main gating functions. You can't take on an Ace until
you both have enough intel and have completed enough prerequisite missions, so if
we can grant intel via AP instead of in-game we can control when the Ace mission unlocks.

MOM unlocks are mostly nice-to-haves but we probably want to mark a few useful ones
as progression, so that the player isn't thrown into later missions with no support.
Either specific unlocks or a general count.

Generally speaking, challenges only reward money, cards reward money and intel,
missions and collectables reward money and MoM unlocks.

Certain cards can only be verified during a mission, and unlocking some of those
missions requires collecting sufficient intel.

Unlocks from collectibles are generally given at certain thresholds, e.g. you get
unlocks at 1, 5, and 10 blueprints, but 2-4 and 6-9 give you nothing.

This suggests our check and item pools.
Checks are: collectibles, mission completion, mission bonus completion, and verification.
Items are: MoM unlocks, money, intel, and maybe collectibles.

For collectibles, we have two ways of handling them -- one is that the collectibles
are in the pool, and finding them gets you either additional checks or MoM unlocks
once you reach the threshold points.

The other option is that we remove collectables entirely, and the things they would
normally unlock are added to the pool directly, and we generate filler like free
airstrikes or additional money to make up the difference (since there's about 250
collectibles which, between them, unlike about 30 MoM entries, half of those cheat
codes rather than actual items).

For implementation, I need to do a bunch of reverse engineering.

The game, broadly speaking, has "primary" information:
- which collectibles are found;
- which missions and bonus objectives are complete;
- which challenges are complete;
- which cards are verified
- how much money you have

And secondary information, which can be derived from first principles from the
primary info:
- how many collectables you have;
- which items are available in the MoM;
- how much intel you have;
- which cards are present in the world;
- which card missions are available.

My hope is that the secondary information is stored in RAM and updated when the
primaries change, rather than being recalculated from scratch every time you open
the PDA or similar. In that case, we can watch the RAM for the primary info to
figure out what the player has accomplished and send checks, and write the ram
for the secondary info to control what is actually unlocked.


PCSX2 supports the PINE remote debugging protocol.
Socket is created in $XDG_RUNTIME_DIR/pcsx2.sock.<slot> on linux, /tmp if XDGRTD is unset
OSX uses $TMPDIR/pcsx2.sock.<slot> with TMPDIR defaulting to /tmp
The .slot may be omitted if the default slot is used
Windows uses TCP ports, slot == port number

Messages are in LTV format, little-endian.

L is a uint32_t and includes the size of the L and T fields.
T is a uint8_t.

Opcodes we care about are:
0,1,2,3: read an 8,16,32,64-bit value, V is uint32_t address
4,5,6,7: write, V is uint32_t address followed by uint{8,16,32,64}_t value
Possibly also 9 (save state) and $A (load state), argument is a uint8_t for the state slot
$B, $C, $D, $E, and $F may be useful for safety checks:
- game title
- game id
- game uuid
- game version
- emulator status (either 0 running, 1 paused, 2 shutdown)
These all return strings in the form of:
- 32-bit size including the null terminator
- null terminated string

Responses are also LTV, T is either $00 (success) or $FF (fail)
V depends on the message, for reads it's the value read, for writes or saves/loads it's empty

Batch messages consist of a single L field, followed by a series of (T,V) pairs
Responses consist of L, one T for the entire batch, then all Vs concatenated

Mercs uses Lua 5.0.1 internally. Source code is stored, compressed, in the DSK files.
It is (I think) loaded, decompressed, and compiled at game startup, the bytecode
retained and the source discarded.

Layout of a lua object (lua_TObject):
{
  int tt;  // tag: nil bool luserdata number string table function fuserdata thread
  Value union {
    int b; // if boolean
    lua_Number n; // if number -- what type is this on the PS2?
    void *p; // luserdata?
    GCObject *gc; // collectable objects
  }
}

A GCObject is
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};

// this is the "header for the string table"
// accessed with
#define getstr(ts)	cast(const char *, (ts) + 1)
// so an actual string has an implicit 'char str_data[]' at the end
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    lu_hash hash;
    size_t len;
  } tsv;
} TString;

// so in memory it looks something like:
{
  void*;
  byte; // always 4, LUA_TSTRING
  byte; // 0 or 1
  byte; // always 0
  hash; // 4 bytes?
  size; // 4 bytes on MIPS I think
  actual string data, null terminated
}

#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

typedef struct Node {
  TObject i_key;
  TObject i_val;
  struct Node *next;  /* for chaining */
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TObject *array;  /* array part */
  Node *node;
  Node *firstfree;  /* this position is free; all positions after it are full */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;


00578594 - ID of current mission. Doesn't seem to be a memory address.
00579468 - mission phase counter? RA checks for this to be 3 to count a mission as complete.

00558BF0
00558BF4 - used for the cash display on the HUD. Not, however, the actual cash in inventory!

005007f4 - pointer to character info? RA derefs this and then adds 0x74 to get model index
004a4cac - cheat flag or maybe saveload flag? most RAs are configured to reset when this is nonzero


; fulfill first three SK missions in the south province
N:0xX005131e0=1
  _I:0xX00501a44_O:0xX00000010=1
  _O:0xX00558c8c=999
  _O:0xX00558c8c=3000
  _O:0xX00558c8c=50
  _P:0xX005153f0=1.1.
S
B:1  ; accumulator to -1
  _I:0x 005029be   ; read index from uint16_t
  _M:0xL00da38c0=3 ; read memory + index, sub 1, compare to 3 -- looks like $00da38c0's lower nybble is "index of next SK mission"
_B:1
  _I:0x 005029be
  _d0xL00da38c0=2
_O:0xX004a40e8=1400005746
  _Q:0xX004a40e8=1634886770
_Q:0x 005029be>0
_0xX00578594=3326808767
_I:0x 005029be_Q:0xL00da38c0<=4
S
0xX00578594=3326808767
_d0xX00579468!=3_0xX00579468=3


1A77560 -- player money (is this stable across runs?) in savestate 5. This is a float!