# Mercenaries Archipelago

## TODO

Items marked with a ! are things I want to have working before alpha.

- Checks:
  - Number of unique vehicles destroyed, and/or specific vehicle types
    - Need to map out which types belong to which array slots
    - Need to also evaluate which vehicles are available when so we can set
      progression logic!
  - See if either the vehicle stats approach or the bounty stats approach works for
    challenge completions, vehicles driven, weapons found
- Items:
  - Faction reputation bonuses
    - Probably needs more code injection
  - Stuff that needs more research to see if it's possible:
    - Resource refills

## Other notes

Notes on AP for Mercenaries: Playground of Destruction.

Totals
 52 cards
    4 aces
   12 face cards
    1 number
   35 missable numbers
 47 missions
   11 allies
   12 SK
   12 mafia
   12 china
 ?? missable bonus objectives
 36 collectable thresholds
    2 monuments - 10 20
    6 listening posts - 10 20 30 40 50 55
   14 blueprints 1 5 10 15 20 30 40 50 60 70 80 90 100 110
   14 treasures 1 5 10 15 20 30 40 50 60 70 80 90 100 110
135 total not counting individual collectibles

301 collectibles
   25 monuments
   56 listening posts
  110 blueprints
  110 treasures
436 total checks with individual collectables

 63 merchant unlocks
 48 intel bonuses
 11 skins
 13 money bonuses
135 total items

Ideas for items in the pool:
- MOM unlocks (are these in lua? need to unlock MOM ingame to check)
  - maybe have cheats as separate pool items
- intel (hard -- where the fuck is this stored?)
- money (where is this???)
  - think I've found it: 1A77560; might also need to update 558BF0 or 558BF4 when wiggling it
  - might be dynamically allocated though :(
  - found it by verifying a card so that Player_UpdateMoney() gets called, then stepping
    through and watching the FPU registers until they converged on the final result, then
    jumping ahead dozens of instructions at a time while searching memory for that value
  - this is a float!
- reputation
  - RA has achievements for this (max/min reputation with all factions) that we can use

Intel and MOM unlocks are our main gating functions. You can't take on an Ace until
you both have enough intel and have completed enough prerequisite missions, so if
we can grant intel via AP instead of in-game we can control when the Ace mission unlocks.

MOM unlocks are mostly nice-to-haves but we probably want to mark a few useful ones
as progression, so that the player isn't thrown into later missions with no support.
Either specific unlocks or a general count.

Generally speaking, challenges only reward money, cards reward money and intel,
missions and collectables reward money and MoM unlocks.

Certain cards can only be verified during a mission, and unlocking some of those
missions requires collecting sufficient intel.

Unlocks from collectibles are generally given at certain thresholds, e.g. you get
unlocks at 1, 5, and 10 blueprints, but 2-4 and 6-9 give you nothing.

This suggests our check and item pools.
Checks are: collectibles, mission completion, mission bonus completion, and verification.
Items are: MoM unlocks, money, intel, and maybe collectibles.

For collectibles, we have two ways of handling them -- one is that the collectibles
are in the pool, and finding them gets you either additional checks or MoM unlocks
once you reach the threshold points.

The other option is that we remove collectables entirely, and the things they would
normally unlock are added to the pool directly, and we generate filler like free
airstrikes or additional money to make up the difference (since there's about 250
collectibles which, between them, unlike about 30 MoM entries, half of those cheat
codes rather than actual items).

For implementation, I need to do a bunch of reverse engineering.

The game, broadly speaking, has "primary" information:
- which collectibles are found;
- which missions and bonus objectives are complete;
- which challenges are complete;
- which cards are verified
- how much money you have

And secondary information, which can be derived from first principles from the
primary info:
- how many collectables you have;
- which items are available in the MoM;
- how much intel you have;
- which cards are present in the world;
- which card missions are available.

My hope is that the secondary information is stored in RAM and updated when the
primaries change, rather than being recalculated from scratch every time you open
the PDA or similar. In that case, we can watch the RAM for the primary info to
figure out what the player has accomplished and send checks, and write the ram
for the secondary info to control what is actually unlocked.


PCSX2 supports the PINE remote debugging protocol.
Socket is created in $XDG_RUNTIME_DIR/pcsx2.sock.<slot> on linux, /tmp if XDGRTD is unset
OSX uses $TMPDIR/pcsx2.sock.<slot> with TMPDIR defaulting to /tmp
The .slot may be omitted if the default slot is used
Windows uses TCP ports, slot == port number

Messages are in LTV format, little-endian.

L is a uint32_t and includes the size of the L and T fields.
T is a uint8_t.

Opcodes we care about are:
0,1,2,3: read an 8,16,32,64-bit value, V is uint32_t address
4,5,6,7: write, V is uint32_t address followed by uint{8,16,32,64}_t value
Possibly also 9 (save state) and $A (load state), argument is a uint8_t for the state slot
$B, $C, $D, $E, and $F may be useful for safety checks:
- game title
- game id
- game uuid
- game version
- emulator status (either 0 running, 1 paused, 2 shutdown)
These all return strings in the form of:
- 32-bit size including the null terminator
- null terminated string

Responses are also LTV, T is either $00 (success) or $FF (fail)
V depends on the message, for reads it's the value read, for writes or saves/loads it's empty

Batch messages consist of a single L field, followed by a series of (T,V) pairs
Responses consist of L, one T for the entire batch, then all Vs concatenated

Mercs uses Lua 5.0.1 internally. Source code is stored, compressed, in the DSK files.
It is (I think) loaded, decompressed, and compiled at game startup, the bytecode
retained and the source discarded.

Layout of a lua object (lua_TObject):
{
  int tt;  // tag: nil bool luserdata number string table function fuserdata thread
  Value union {
    int b; // if boolean
    lua_Number n; // if number -- what type is this on the PS2?
    void *p; // luserdata?
    GCObject *gc; // collectable objects
  }
}

A GCObject is
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};

// this is the "header for the string table"
// accessed with
#define getstr(ts)	cast(const char *, (ts) + 1)
// so an actual string has an implicit 'char str_data[]' at the end
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    lu_hash hash;
    size_t len;
  } tsv;
} TString;

// so in memory it looks something like:
{
  void*;
  byte; // always 4, LUA_TSTRING
  byte; // 0 or 1
  byte; // always 0
  hash; // 4 bytes?
  size; // 4 bytes on MIPS I think
  actual string data, null terminated
}

#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

typedef struct Node {
  TObject i_key;
  TObject i_val;
  struct Node *next;  /* for chaining */
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TObject *array;  /* array part */
  Node *node;
  Node *firstfree;  /* this position is free; all positions after it are full */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;


00578594 - ID of current mission. Doesn't seem to be a memory address.
00579468 - mission phase counter? RA checks for this to be 3 to count a mission as complete.

00558BF0
00558BF4 - used for the cash display on the HUD. Not, however, the actual cash in inventory!

005007f4 - pointer to character info? RA derefs this and then adds 0x74 to get model index
004a4cac - cheat flag or maybe saveload flag? most RAs are configured to reset when this is nonzero

Retrieve RA achievements definition with:
curl https://retroachievements.org/dorequest.php \
  --data 'r=achievementsets&m=316ad24970b2f19558bc2bda7eb98d81' \
  -A 'PCSX2 v2.4.0 (nixos)' | jq > achievements


; fulfill first three SK missions in the south province
N:0xX005131e0=1
  _I:0xX00501a44_O:0xX00000010=1
  _O:0xX00558c8c=999
  _O:0xX00558c8c=3000
  _O:0xX00558c8c=50
  _P:0xX005153f0=1.1.
S
B:1  ; accumulator to -1
  _I:0x 005029be   ; read index from uint16_t
  _M:0xL00da38c0=3 ; read memory + index, sub 1, compare to 3 -- looks like $00da38c0's lower nybble is "index of next SK mission"
_B:1
  _I:0x 005029be
  _d0xL00da38c0=2
_O:0xX004a40e8=1400005746
  _Q:0xX004a40e8=1634886770
_Q:0x 005029be>0
_0xX00578594=3326808767
_I:0x 005029be_Q:0xL00da38c0<=4
S
0xX00578594=3326808767
_d0xX00579468!=3_0xX00579468=3


1A77560 -- player money (is this stable across runs?) in savestate 5. This is a float!

DA38C0 -- I think this is the scribmem block, but writing something to it
rewrites the whole fucking thing :<
504c90 holds a pointer to it

writing a string to scribmem
looks like it gets a useful pointer to $501c88 in s2
Adds $1008 to get $502c90 in a1
then does
  sll v0,v0,1

function fOdfSold()
  local n = 15
  if tMafiaShop[_shop_iCurrentItem].template then
    Shop_UnlockItem(tMafiaShop[_shop_iCurrentItem].template)
    AddTooltip {
      sMessage = '[green]' .. Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc) .. ' added to shop';
      nDisplayDuration = 6
    }
  else
    n = 30
  end

  _shop_iCurrentItem += 1
  Utility_WriteNumberToScribbleMemory('iCurrentShopItem', _shop_iCurrentItem)
  Faction_ModifyRelation('mafia', 'prokat', n)

  if tMafiaShop[_shop_iCurrentItem] then
    hOdfSold = Event_OdfSold('fOdfSold', 'b', tMafiaShop[_shop_iCurrentItem].odf)
    r1: Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc)
    r2: Utility_GetStringById('faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorFactionName', 'faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', tMafiaShop[_shop_iCurrentItem].desc)
  else
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', nil)
    fShopkeeperKilled()

function fShopkeeperKilled()
  Ui_RemoveDisplayMarkerActor('mafia_shopkeeper')
  Actor_EnableScriptedUse('mafia_shopkeeper', false, 'actions.talk', false)
  hActorUsed = Event_CancelEvent(hActorUsed)
  hOdfSold = Event_CancelEvent(hOdfSold)


To inject a debug logger, we replace util_PrintDebugMsg and Debug_Printf
  [Node$01A8214C] 'util_PrintDebugMsg' [h=A2961C17,$00A12000]: function$009A2BC0 'util_PrintDebugMsg' [h=A2961C17,$00A12000]
    CONST$00960990 'bDebugOutput' [h=2660F98C,$009A6CC0]
    CONST$00960998 'Debug_Printf' [h=445430CF,$0098B6A0]
    CODE $009974E0
         0 01000005 GETGLOBAL r1 := _G['bDebugOutput' [h=2660F98C,$009A6CC0]]
         1 01008018      TEST not r1: r1 := r1 ; or skip
         2 00800094       JMP +3 ; 6
         3 01000045 GETGLOBAL r1 := _G['Debug_Printf' [h=445430CF,$0098B6A0]]
         4 02000000      MOVE r2 := r0
         5 01010059      CALL r1 (1 args) => 0 results
         6 0000801B    RETURN r0 ... r-1

replace constant 0 ('bDebugOutput') with 'sDebugBuffer'
replace constant 1 ('Debug_Printf') with '------------'
Replace code segment with:

  GETGLOBAL r1, 'sDebugBuffer'
  MOVE r2 := r0
  CONCAT r1, r1 .. r2
  SETGLOBAL r1, 'sDebugBuffer'
  MOVE r0, r0
  MOVE r0, r0
  RETURN

Problem: this fails if sDebugBuffer is nil, since you can't concat nil and string
The traditional solution to this is a test-and-set, but the implementation of test
assumes the instruction after it is always a jump, and will crash the VM if it's not

Might be able to replace the code segment of table_debug instead, that's a table
prettyprinter and gives me 84 instructions to work with.

In that case, I can ultimately replace it with something that, every time a debug
message is logged, instead updates a data structure in memory with information
about which things have been checked, using Utility_ReadFooFromScribbleMemory.


gameflow_AttemptAceMissionUnlock
Debug_EnableDebugMenu
Utility_GetStringById
Debug_Break
bDebugOutput
            Debug_Printf



Intel!
GetCardIntelValue returns:
- the number for number cards (so they are worth 2..10 intel points, for a total of 54)
- iFaceIntel (30) for face cards
- iAceIntel (0) for aces
iTargetIntel is set to 80
iMaxIntel is set to 34, but doesn't seem to be used.
Assuming these numbers don't change for later chapters.

I can set iTargetIntel to anything and it will appear to work, but is only checked
when I actually verify a card.

I could perhaps rig the debug logger to call `gameflow_AttemptAceMissionUnlock()` instead.
`gameflow_GetIntelTotal` is also written in lua and can thus be replaced.

If we can call Ui_PrintHudMessage() WE CAN DELIVER MESSAGES TO THE PLAYER HOLY SHIT

What do we have to work with?
0,1 util_PrintDebugMsg -- two constants, 6 opcodes
0,1 Tooltip_Debug -- five constants, 13 opcodes
0,1 util_DebugStartMissionChainLoading -- 30+ constants, 167 opcodes
1 table_Debug -- 13 constants, 84 opcodes
0,1 ConTooltip_Debug -- 2 constants, 11 opcodes
1 DebugSkipToMission -- 20+ constants, 114 opcodes
not all of these are loaded at all times!

So how do we do this?
We need a global we can use as an idempotency flag

We can steal some constants that aren't used anywhere else:
DebugMissionChainLoading_QuadrantIndex
DebugMissionChainLoading_FactionIndex
DebugMissionChainLoading_SeqNumberIndex


; money info
0054E620 -> 01AB3400 -> 0.833471417427063
0054E4B0 -> 01A76A00 -> 65000.0 ; nan in the tutorial, but seems stable thereafter
00558B4C -> 01A76A00 -> 65000.0 ; stable unless you're in a vehicle
00559634 -> 01A76A00 -> 65000.0 ; as above
007DA310 -> 01A76A00 -> 65000.0 ; null pointer in the tutorial, fine afterwards?
00BF2524 -> 000000A2 -> 0.0
00D9B030 -> 01940500 -> -3.595866417927342e+35
Need to check these against later chapters to see if $007DA310 is stable.
If not, $00558B4C are probably our best bet if we can distinguish between
players and vehicles.

util_GetMissionArcTable
returns something like

{ -- r0
  allies = {
    sw = { 1, 3, 4, 5, 6, 8 };
    nw = { 1, 3, 4, 2, 8 };
  };
  china = mafia = sk = {
    sw = { 1, 2, 3, 4, 5, 6 };
    nw = { 1, 2, 3, 4, 5, 6 };
  };
}

util_MissionAssetNumToMissionSeqNum uses this, indexing by r1 (faction) and then r0 (province)
and finally iterating looking for a match for r2, so it's called as something like:
('allies', 'nw', 8) and returns 5.

GetCurrentMission
ScribNumber('mission_accepted') or return nil
r0 = ScribString('SkipTo_Map')
r1 = ScribString('current_faction')
r2 = ScribNumber('current_'..r1..'_mission')

return r0 .. '_' .. r1 .. r2

gameflow_ShouldGameStateApply has useful constants:
[0] Utility_ReadNumberFromScribbleMemory
[5] current_allies_mission
[7] current_china_mission
[9] current_mafia_mission
[11] current_sk_mission

r3 = scrib 'mission_accepted'
r4 = scrib 'current_faction'
r5 = {
  allies = scrib 'current_allies_mission';
  -- etc --
}
r6 = true
util_PrintDebugMsg(...)



elif cmd == "ReceivedItems":
            payload = {
                'cmd': 'ReceivedItems',
                'items': [self.item_names.lookup_in_game(item.item) for item in args['items']],
                'item_ids': [item.item for item in args["items"]],
                'locations': [self.location_names.lookup_in_slot(location.location, location.player) for location in args['items']],
                'players': [self.player_names[player.player] for player in args["items"]],
                'index': args["index"]
            }


Free airstrike addresses -- these are not consistent across runs, we need to find
pointers to them.
01A4F424 -- tank busters in ace of clubs
01A4F764 -- cluster bombs in ace of clubs
01A4DBE4 -- tank buster from earlier save file -- cluster bomb is at the same offset relative to it!

These are populated by AddSupport:
  [Node$01A2F014] 'AddSupport' [h=ECAE1471,$0099CE00]: function$00993F40 'AddSupport' [h=ECAE1471,$0099CE00]
    CONST$009EB780 k0  'mission_AddSupport' [h=EEFD8C7C,$00A2A540]
    CONST$009EB788 k1  'template_support_tankbuster' [h=80AC0C95,$009D1180]
    CONST$009EB790 k2  TObject(4.0)
    CONST$009EB798 k3  'template_support_clusterbomb' [h=8CCFE6D7,$00A0CF80]
    CONST$009EB7A0 k4  'Event_RelativeTimer' [h=AD23F6E2,$009F7840]
    CONST$009EB7A8 k5  'InitialBlips' [h=40D957D3,$00996480]
    CONST$009EB7B0 k6  'b' [h=00000083,$00983380]
    CONST$009EB7B8 k7  TObject(0.5)
     CODE$00A860C0
      000 00000005 GETGLOBAL r0 := _G[k0 ('mission_AddSupport' [h=EEFD8C7C,$00A2A540])]
      001 0101000A  NEWTABLE r1 := {} (#a=2, #h=0)
      002 0201000A  NEWTABLE r2 := {} (#a=2, #h=0)
      003 03000041     LOADK r3 := k1 ('template_support_tankbuster' [h=80AC0C95,$009D1180])
      004 04000081     LOADK r4 := k2 (TObject(4.0))
      005 0200005F   SETLIST r2 [1]
      006 0301000A  NEWTABLE r3 := {} (#a=2, #h=0)
      007 040000C1     LOADK r4 := k3 ('template_support_clusterbomb' [h=8CCFE6D7,$00A0CF80])
      008 05000081     LOADK r5 := k2 (TObject(4.0))
      009 0300005F   SETLIST r3 [1]
      010 0100005F   SETLIST r1 [1]
      011 00010059      CALL r0 (1 args) => 0 results
      012 00000105 GETGLOBAL r0 := _G[k4 ('Event_RelativeTimer' [h=AD23F6E2,$009F7840])]
      013 01000141     LOADK r1 := k5 ('InitialBlips' [h=40D957D3,$00996480])
      014 02000181     LOADK r2 := k6 ('b' [h=00000083,$00983380])
      015 030001C1     LOADK r3 := k7 (TObject(0.5))
      016 00020059      CALL r0 (3 args) => 0 results
      017 0000801B    RETURN

Which calls mission_AddSupport:
  [Node$01A2F0F0] 'mission_AddSupport' [h=EEFD8C7C,$00A2A540]: function$00975FA0 'mission_AddSupport' [h=EEFD8C7C,$00A2A540]
    CONST$009DA840 k0  'type' [h=0070EF71,$009875A0]
    CONST$009DA848 k1  'table' [h=10F2114B,$0098D780]
    CONST$009DA850 k2  'Support_AddItem' [h=E53E40DA,$0098F7E0]
    CONST$009DA858 k3  TObject(1.0)
    CONST$009DA860 k4  TObject(2.0)
     CODE$00B1FE40
      000 00000018      TEST not r0 : r0 := r0
      001 00800454       JMP +18 ; 20
      002 01000000      MOVE r1 := r0
      003 02020003   LOADNIL r2 ... r4
      004 0180031E  TFORPREP WIP
      005 05000005 GETGLOBAL r5 := _G[k0 ('type' [h=0070EF71,$009875A0])]
      006 06020000      MOVE r6 := r4
      007 05010099      CALL r5 (1 args) => 1 results
      008 0002BED5        EQ r5 != k1 ('table' [h=10F2114B,$0098D780])
      009 00800114       JMP +5 ; 15
      010 05000085 GETGLOBAL r5 := _G[k2 ('Support_AddItem' [h=E53E40DA,$0098F7E0])]
      011 06023F46  GETTABLE r6 := r4[k3 (TObject(1.0))]
      012 07023F86  GETTABLE r7 := r4[k4 (TObject(2.0))]
      013 05018059      CALL r5 (2 args) => 0 results
      014 00800094       JMP +3 ; 18
      015 05000085 GETGLOBAL r5 := _G[k2 ('Support_AddItem' [h=E53E40DA,$0098F7E0])]
      016 06020000      MOVE r6 := r4
      017 05010059      CALL r5 (1 args) => 0 results
      018 0100005D  TFORLOOP WIP
      019 007FFC14       JMP -15 ; 5
      020 0000801B    RETURN

Airstrike coupon balancing
Giving the player N free airstrikes keeps them in the player's support bar once
the tally hits zero and they can buy more at market price -- this is presumably
so that in missions that require the use of a given airstrike you can't be softlocked
by running out as long as you have some cash.

Ideally, I would like to take it away when the tally hits zero, but I don't have
enough code to do that and it's not clear I can query airstrike quantity from lua
in any case, and it's hard to find from C.

Alternate idea: implement a new economy. Leave the prices of temporarily granted
airstrikes alone, but reduce the prices of shop unlocks *and* all monetary rewards
by a factor of, say, 1000. This gives us airstrike prices ranging from 2 (medical crate)
to 1000 (cheat crate) -- but since these prices are applied in the shop array,
rather than in the default pricing, a la carte purchase of couponed airstrikes
becomes impossibly expensive.

Alternately, we could leave rewards the same and adjust the prices *up* by a factor
of 1000 (or more).

Unfortunately, here's where the info is stored:
Shop prices: DATAPS2/DATAPOD/ITEMSHOP.INI on disc, unknown at runtime
Airstrike prices: DATAPS2/ASSETS.DSK...probably
Mission rewards: DATAPS2/MISSION.INI on disc, unknown at runtime
Bounty rewards: DATAPS2/ASSETS.DSK ("cashValue" key) on disc, unknown at runtime
Challenge rewards: ???

Simplest is probably to crank shop and airstrike prices and make them impossible
to afford without unlocks or coupons, although something I need to check is: if
you've unlocked something and you get a coupon for it, does it use the base price
or the unlocked price? If the latter this is only a solution for things that aren't
also sold in the MOM...which to be fair almost everything has an equivalent.

Fuel-Air Bomb template price is at $51E510
This is template_support_p_fuelairbomb, the mafia version -- not sure where the
non-mafia version is, need to map out this whole array.
This appears to be spaced 32 bytes apart, and contains entries in the same
order as the shop indices -- presumably the shop index is into this array.
But where are the prices for the other things?

Immediately after the price is a flag: 0 for vehicle, 1 for supplies, 2 for AS.

There don't appear to be any extra array entries containing things for the non-shop
support items. :/

Looks like that array may start at $5240DC and contain entries spaced 10 words
(40 bytes) apart, with the first price at $5240FC.

Unfortunately, changing the values there does not appear to affect the price of
the airstrike in the menu, and opening the PDA resets all of these values.

There must be another array somewhere that this data is copied from. Where?

$0051DE90 - $0051E650: template data for shop
$005240FC - $005248CC: an array of 51 40-byte structs that look like they might be airstrike data, but which are overwritten when the PDA is opened.

state 9, a support_tankbuster costs $136,500
After killing some mafia dudes it costs $148,500
So the cost depends on reputation WITH THE MAFIA even if I'm ordering the airstrike from another faction
With mafia reputation at exactly 100, the tankbuster costs 120,000
the p_tankbuster, at reputation 100, costs 200,000 and it won't let me use it if I don't have any freebies??

the p_surgicalstrike costs 40,000 -- I guess it uses the base price without reputation adjustment if you don't have it unlocked? -- but I can still use it even if I don't have any freebies

it looks like this is actually a result of the "can you use this" check being performed against the base price, not the reputation-adjusted price

So I think maybe what I do is, I make coupons available only for shop items, and set the base price in 0051DE90 to be 1000x normal or similar, it's a uint32_t, it can handle it
and then if you have it unlocked you get the in-shop price, and if you don't you get the inflated base price, I think

at reputation 100, something unlocked in the shop that normally costs 200k instead costs 80k

Tragically, the shop template data is *only* used to populate the shop, not the quickbar, even when using the p_ versions :/
Where the hell does quickbar pricing info come from????

$55897c - spaced 56 bytes apart and in hundreds of dollars, might be it? nope

Ok, so, new idea
Rather than having coupons for specific things, we have coupons for random things:
- Airstrike/Supplies/Vehicle coupon give you a random one of those
- Allies/China/Mafia/SK coupon give you a random thing from that faction

We might in the future want to rate-limit them or something, dispense a new one
every minute or every time you find a check or something.
