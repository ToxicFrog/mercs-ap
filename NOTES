# Mercenaries Archipelago

## TODO

- Bugfixes:
  - Non-idempotency of money
    - can use Set and Get commands on the server for this to record what we have
      and have not successfully delivered to the player
- Checks:
  - Number of bounties
    - Option to set point beyond which there will be no progression items
  - Number of unique vehicles destroyed, and/or specific vehicle types
    - Need to map out which types belong to which array slots
    - Need to also evaluate which vehicles are available when so we can set
      progression logic!
  - See if either the vehicle stats approach or the bounty stats approach works for
    challenge completions, vehicles driven, weapons found
- Items:
  - Generic discount
    - Applies to your most expensive item
  - Faction reputation bonuses
    - Probably needs more code injection
  - Faction floor increases
    - Can be done with K-hacking on AttemptFactionMoodClamp, assuming it gets called often enough
  - Stuff that needs more research to see if it's possible:
    - Airstrike coupons
    - Resource refills
- Hints:
  - Hint what number cards are carrying when their location is revealed by a mission
    - Need to send a CreateHints packet for the locations iff we haven't checked them yet
  - Perhaps: capturing cards alive gives hints for where your progression items are
    - I think this requires us to bake in the hints at generation time?
- Other:
  - Use Ui_PrintHudMessage to display messages in game if possble
    - Possible hooks: DebugSkipToMission, Tooltip_Debug, ConTooltip_Debug, util_DebugStartMissionChainLoading

## Other notes

Notes on AP for Mercenaries: Playground of Destruction.

Totals
 52 cards
    4 aces
   12 face cards
    1 number
   35 missable numbers
 47 missions
   11 allies
   12 SK
   12 mafia
   12 china
 ?? missable bonus objectives
 36 collectable thresholds
    2 monuments - 10 20
    6 listening posts - 10 20 30 40 50 55
   14 blueprints 1 5 10 15 20 30 40 50 60 70 80 90 100 110
   14 treasures 1 5 10 15 20 30 40 50 60 70 80 90 100 110
135 total not counting individual collectibles

301 collectibles
   25 monuments
   56 listening posts
  110 blueprints
  110 treasures
436 total checks with individual collectables

 63 merchant unlocks
 48 intel bonuses
 11 skins
 13 money bonuses
135 total items

This is a perfect match if we don't turn on individual collectables or condense
intel.
If we do either, we need filler, possibly a lot of it.
Possible fillers are:
- money in various amounts
- discounts for shop items (extra useful if we start the prices high!)
- faction reputation bonuses
- health/ammo/grenade refills
- single-use airstrikes

RA has achievements for "complete 3/6/9/12 missions for [faction]" which we can
base this on. There appear to be data structures for "what is the index of the
next mission for this faction".
- clear mission primary objective [is check]
  - money
  - reputation
  - MOM unlocks

RA has achievements for at least some and possibly all of these.
They're missable.
- clear mission bonus objective [missable]
  - money
  - reputation
  - MOM unlocks
  - if not completed, you have to reload an earlier save and retry

RA has leaderboards for these, which we can turn into checks for them.
- clear challenge
  - money

RA has counter achievements for these, the code is incredibly gnarly but I can
probably figure it out.
If I can get it from lua that would probably be more readable, but also, there's
like 250 of them, which is a pretty big constant table...
- find collectable [is check]
  - money per
  - reputation per
  - cheats at certain thresholds
  - MOM unlocks at certain thresholds
  - money at certain thresholds
  - might make each collectable a specific check, or might be easier to just
    count all collectables and unlock progressive checks

All cards are tracked in memory, RA has the addresses as alt conditions for the
"capture cards" achievements. These are spaced 0x28 bytes apart so it seems
likely that what we have here are arrays of card_t.
The status field for each card is a uint32_t and is 1 for "at large", 2 for "killed"
and 3 for "captured". 3 is set as soon as you get the mission complete popup, it
looks like; you only get the 2 next time you open the PDA.
- verify number card [missable]
  - money
  - intel
  - any that you haven't gotten before verifying the Ace will vanish when the
    Ace mission is completed
- verify face card
  - money
  - intel
  - MOM unlocks
  - always part of a mission
- verify Ace
  - money
  - intel
  - MOM unlocks
  - always part of a mission
  - this is a point of no return that vanishes all number cards of the same suit
    and spawns the next suit


Ideas for items in the pool:
- MOM unlocks (are these in lua? need to unlock MOM ingame to check)
  - maybe have cheats as separate pool items
- intel (hard -- where the fuck is this stored?)
- money (where is this???)
  - think I've found it: 1A77560; might also need to update 558BF0 or 558BF4 when wiggling it
  - might be dynamically allocated though :(
  - found it by verifying a card so that Player_UpdateMoney() gets called, then stepping
    through and watching the FPU registers until they converged on the final result, then
    jumping ahead dozens of instructions at a time while searching memory for that value
  - this is a float!
- reputation
  - RA has achievements for this (max/min reputation with all factions) that we can use

Intel and MOM unlocks are our main gating functions. You can't take on an Ace until
you both have enough intel and have completed enough prerequisite missions, so if
we can grant intel via AP instead of in-game we can control when the Ace mission unlocks.

MOM unlocks are mostly nice-to-haves but we probably want to mark a few useful ones
as progression, so that the player isn't thrown into later missions with no support.
Either specific unlocks or a general count.

Generally speaking, challenges only reward money, cards reward money and intel,
missions and collectables reward money and MoM unlocks.

Certain cards can only be verified during a mission, and unlocking some of those
missions requires collecting sufficient intel.

Unlocks from collectibles are generally given at certain thresholds, e.g. you get
unlocks at 1, 5, and 10 blueprints, but 2-4 and 6-9 give you nothing.

This suggests our check and item pools.
Checks are: collectibles, mission completion, mission bonus completion, and verification.
Items are: MoM unlocks, money, intel, and maybe collectibles.

For collectibles, we have two ways of handling them -- one is that the collectibles
are in the pool, and finding them gets you either additional checks or MoM unlocks
once you reach the threshold points.

The other option is that we remove collectables entirely, and the things they would
normally unlock are added to the pool directly, and we generate filler like free
airstrikes or additional money to make up the difference (since there's about 250
collectibles which, between them, unlike about 30 MoM entries, half of those cheat
codes rather than actual items).

For implementation, I need to do a bunch of reverse engineering.

The game, broadly speaking, has "primary" information:
- which collectibles are found;
- which missions and bonus objectives are complete;
- which challenges are complete;
- which cards are verified
- how much money you have

And secondary information, which can be derived from first principles from the
primary info:
- how many collectables you have;
- which items are available in the MoM;
- how much intel you have;
- which cards are present in the world;
- which card missions are available.

My hope is that the secondary information is stored in RAM and updated when the
primaries change, rather than being recalculated from scratch every time you open
the PDA or similar. In that case, we can watch the RAM for the primary info to
figure out what the player has accomplished and send checks, and write the ram
for the secondary info to control what is actually unlocked.


PCSX2 supports the PINE remote debugging protocol.
Socket is created in $XDG_RUNTIME_DIR/pcsx2.sock.<slot> on linux, /tmp if XDGRTD is unset
OSX uses $TMPDIR/pcsx2.sock.<slot> with TMPDIR defaulting to /tmp
The .slot may be omitted if the default slot is used
Windows uses TCP ports, slot == port number

Messages are in LTV format, little-endian.

L is a uint32_t and includes the size of the L and T fields.
T is a uint8_t.

Opcodes we care about are:
0,1,2,3: read an 8,16,32,64-bit value, V is uint32_t address
4,5,6,7: write, V is uint32_t address followed by uint{8,16,32,64}_t value
Possibly also 9 (save state) and $A (load state), argument is a uint8_t for the state slot
$B, $C, $D, $E, and $F may be useful for safety checks:
- game title
- game id
- game uuid
- game version
- emulator status (either 0 running, 1 paused, 2 shutdown)
These all return strings in the form of:
- 32-bit size including the null terminator
- null terminated string

Responses are also LTV, T is either $00 (success) or $FF (fail)
V depends on the message, for reads it's the value read, for writes or saves/loads it's empty

Batch messages consist of a single L field, followed by a series of (T,V) pairs
Responses consist of L, one T for the entire batch, then all Vs concatenated

Mercs uses Lua 5.0.1 internally. Source code is stored, compressed, in the DSK files.
It is (I think) loaded, decompressed, and compiled at game startup, the bytecode
retained and the source discarded.

Layout of a lua object (lua_TObject):
{
  int tt;  // tag: nil bool luserdata number string table function fuserdata thread
  Value union {
    int b; // if boolean
    lua_Number n; // if number -- what type is this on the PS2?
    void *p; // luserdata?
    GCObject *gc; // collectable objects
  }
}

A GCObject is
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};

// this is the "header for the string table"
// accessed with
#define getstr(ts)	cast(const char *, (ts) + 1)
// so an actual string has an implicit 'char str_data[]' at the end
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    lu_hash hash;
    size_t len;
  } tsv;
} TString;

// so in memory it looks something like:
{
  void*;
  byte; // always 4, LUA_TSTRING
  byte; // 0 or 1
  byte; // always 0
  hash; // 4 bytes?
  size; // 4 bytes on MIPS I think
  actual string data, null terminated
}

#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

typedef struct Node {
  TObject i_key;
  TObject i_val;
  struct Node *next;  /* for chaining */
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TObject *array;  /* array part */
  Node *node;
  Node *firstfree;  /* this position is free; all positions after it are full */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;


00578594 - ID of current mission. Doesn't seem to be a memory address.
00579468 - mission phase counter? RA checks for this to be 3 to count a mission as complete.

00558BF0
00558BF4 - used for the cash display on the HUD. Not, however, the actual cash in inventory!

005007f4 - pointer to character info? RA derefs this and then adds 0x74 to get model index
004a4cac - cheat flag or maybe saveload flag? most RAs are configured to reset when this is nonzero

Retrieve RA achievements definition with:
curl https://retroachievements.org/dorequest.php \
  --data 'r=achievementsets&m=316ad24970b2f19558bc2bda7eb98d81' \
  -A 'PCSX2 v2.4.0 (nixos)' | jq > achievements


; fulfill first three SK missions in the south province
N:0xX005131e0=1
  _I:0xX00501a44_O:0xX00000010=1
  _O:0xX00558c8c=999
  _O:0xX00558c8c=3000
  _O:0xX00558c8c=50
  _P:0xX005153f0=1.1.
S
B:1  ; accumulator to -1
  _I:0x 005029be   ; read index from uint16_t
  _M:0xL00da38c0=3 ; read memory + index, sub 1, compare to 3 -- looks like $00da38c0's lower nybble is "index of next SK mission"
_B:1
  _I:0x 005029be
  _d0xL00da38c0=2
_O:0xX004a40e8=1400005746
  _Q:0xX004a40e8=1634886770
_Q:0x 005029be>0
_0xX00578594=3326808767
_I:0x 005029be_Q:0xL00da38c0<=4
S
0xX00578594=3326808767
_d0xX00579468!=3_0xX00579468=3


1A77560 -- player money (is this stable across runs?) in savestate 5. This is a float!

DA38C0 -- I think this is the scribmem block, but writing something to it
rewrites the whole fucking thing :<
504c90 holds a pointer to it

writing a string to scribmem
looks like it gets a useful pointer to $501c88 in s2
Adds $1008 to get $502c90 in a1
then does
  sll v0,v0,1

function fOdfSold()
  local n = 15
  if tMafiaShop[_shop_iCurrentItem].template then
    Shop_UnlockItem(tMafiaShop[_shop_iCurrentItem].template)
    AddTooltip {
      sMessage = '[green]' .. Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc) .. ' added to shop';
      nDisplayDuration = 6
    }
  else
    n = 30
  end

  _shop_iCurrentItem += 1
  Utility_WriteNumberToScribbleMemory('iCurrentShopItem', _shop_iCurrentItem)
  Faction_ModifyRelation('mafia', 'prokat', n)

  if tMafiaShop[_shop_iCurrentItem] then
    hOdfSold = Event_OdfSold('fOdfSold', 'b', tMafiaShop[_shop_iCurrentItem].odf)
    r1: Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc)
    r2: Utility_GetStringById('faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorFactionName', 'faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', tMafiaShop[_shop_iCurrentItem].desc)
  else
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', nil)
    fShopkeeperKilled()

function fShopkeeperKilled()
  Ui_RemoveDisplayMarkerActor('mafia_shopkeeper')
  Actor_EnableScriptedUse('mafia_shopkeeper', false, 'actions.talk', false)
  hActorUsed = Event_CancelEvent(hActorUsed)
  hOdfSold = Event_CancelEvent(hOdfSold)


To inject a debug logger, we replace util_PrintDebugMsg and Debug_Printf
  [Node$01A8214C] 'util_PrintDebugMsg' [h=A2961C17,$00A12000]: function$009A2BC0 'util_PrintDebugMsg' [h=A2961C17,$00A12000]
    CONST$00960990 'bDebugOutput' [h=2660F98C,$009A6CC0]
    CONST$00960998 'Debug_Printf' [h=445430CF,$0098B6A0]
    CODE $009974E0
         0 01000005 GETGLOBAL r1 := _G['bDebugOutput' [h=2660F98C,$009A6CC0]]
         1 01008018      TEST not r1: r1 := r1 ; or skip
         2 00800094       JMP +3 ; 6
         3 01000045 GETGLOBAL r1 := _G['Debug_Printf' [h=445430CF,$0098B6A0]]
         4 02000000      MOVE r2 := r0
         5 01010059      CALL r1 (1 args) => 0 results
         6 0000801B    RETURN r0 ... r-1

replace constant 0 ('bDebugOutput') with 'sDebugBuffer'
replace constant 1 ('Debug_Printf') with '------------'
Replace code segment with:

  GETGLOBAL r1, 'sDebugBuffer'
  MOVE r2 := r0
  CONCAT r1, r1 .. r2
  SETGLOBAL r1, 'sDebugBuffer'
  MOVE r0, r0
  MOVE r0, r0
  RETURN

Problem: this fails if sDebugBuffer is nil, since you can't concat nil and string
The traditional solution to this is a test-and-set, but the implementation of test
assumes the instruction after it is always a jump, and will crash the VM if it's not

Might be able to replace the code segment of table_debug instead, that's a table
prettyprinter and gives me 84 instructions to work with.

In that case, I can ultimately replace it with something that, every time a debug
message is logged, instead updates a data structure in memory with information
about which things have been checked, using Utility_ReadFooFromScribbleMemory.


gameflow_AttemptAceMissionUnlock
Debug_EnableDebugMenu
Utility_GetStringById
Debug_Break
bDebugOutput
            Debug_Printf



Intel!
GetCardIntelValue returns:
- the number for number cards (so they are worth 2..10 intel points, for a total of 54)
- iFaceIntel (30) for face cards
- iAceIntel (0) for aces
iTargetIntel is set to 80
iMaxIntel is set to 34, but doesn't seem to be used.
Assuming these numbers don't change for later chapters.

I can set iTargetIntel to anything and it will appear to work, but is only checked
when I actually verify a card.

I could perhaps rig the debug logger to call `gameflow_AttemptAceMissionUnlock()` instead.
`gameflow_GetIntelTotal` is also written in lua and can thus be replaced.

If we can call Ui_PrintHudMessage() WE CAN DELIVER MESSAGES TO THE PLAYER HOLY SHIT

What do we have to work with?
0,1 util_PrintDebugMsg -- two constants, 6 opcodes
0,1 Tooltip_Debug -- five constants, 13 opcodes
0,1 util_DebugStartMissionChainLoading -- 30+ constants, 167 opcodes
1 table_Debug -- 13 constants, 84 opcodes
0,1 ConTooltip_Debug -- 2 constants, 11 opcodes
1 DebugSkipToMission -- 20+ constants, 114 opcodes
not all of these are loaded at all times!

So how do we do this?
We need a global we can use as an idempotency flag

We can steal some constants that aren't used anywhere else:
DebugMissionChainLoading_QuadrantIndex
DebugMissionChainLoading_FactionIndex
DebugMissionChainLoading_SeqNumberIndex


; money info
0054E620 -> 01AB3400 -> 0.833471417427063
0054E4B0 -> 01A76A00 -> 65000.0 ; nan in the tutorial, but seems stable thereafter
00558B4C -> 01A76A00 -> 65000.0 ; stable unless you're in a vehicle
00559634 -> 01A76A00 -> 65000.0 ; as above
007DA310 -> 01A76A00 -> 65000.0 ; null pointer in the tutorial, fine afterwards?
00BF2524 -> 000000A2 -> 0.0
00D9B030 -> 01940500 -> -3.595866417927342e+35
Need to check these against later chapters to see if $007DA310 is stable.
If not, $00558B4C are probably our best bet if we can distinguish between
players and vehicles.

util_GetMissionArcTable
returns something like

{ -- r0
  allies = {
    sw = { 1, 3, 4, 5, 6, 8 };
    nw = { 1, 3, 4, 2, 8 };
  };
  china = mafia = sk = {
    sw = { 1, 2, 3, 4, 5, 6 };
    nw = { 1, 2, 3, 4, 5, 6 };
  };
}

util_MissionAssetNumToMissionSeqNum uses this, indexing by r1 (faction) and then r0 (province)
and finally iterating looking for a match for r2, so it's called as something like:
('allies', 'nw', 8) and returns 5.

GetCurrentMission
ScribNumber('mission_accepted') or return nil
r0 = ScribString('SkipTo_Map')
r1 = ScribString('current_faction')
r2 = ScribNumber('current_'..r1..'_mission')

return r0 .. '_' .. r1 .. r2

gameflow_ShouldGameStateApply has useful constants:
[0] Utility_ReadNumberFromScribbleMemory
[5] current_allies_mission
[7] current_china_mission
[9] current_mafia_mission
[11] current_sk_mission

r3 = scrib 'mission_accepted'
r4 = scrib 'current_faction'
r5 = {
  allies = scrib 'current_allies_mission';
  -- etc --
}
r6 = true
util_PrintDebugMsg(...)
