# Mercenaries Archipelago

Notes on AP for Mercenaries: Playground of Destruction.

Totals
 52 cards
    4 aces
   12 face cards
    1 number
   35 missable numbers
 47 missions
   11 allies
   12 SK
   12 mafia
   12 china
 ?? missable bonus objectives
 36 collectable thresholds
    2 monuments - 10 20
    6 listening posts - 10 20 30 40 50 55
   14 blueprints 1 5 10 15 20 30 40 50 60 70 80 90 100 110
   14 treasures 1 5 10 15 20 30 40 50 60 70 80 90 100 110
135 total not counting individual collectibles

301 collectibles
   25 monuments
   56 listening posts
  110 blueprints
  110 treasures
436 total checks with individual collectables

 63 merchant unlocks
 48 intel bonuses
 11 skins
 13 money bonuses
135 total items

This is a perfect match if we don't turn on individual collectables or condense
intel.
If we do either, we need filler, possibly a lot of it.
Possible fillers are:
- money in various amounts
- discounts for shop items (extra useful if we start the prices high!)
- faction reputation bonuses
- health/ammo/grenade refills
- single-use airstrikes

RA has achievements for "complete 3/6/9/12 missions for [faction]" which we can
base this on. There appear to be data structures for "what is the index of the
next mission for this faction".
- clear mission primary objective [is check]
  - money
  - reputation
  - MOM unlocks

RA has achievements for at least some and possibly all of these.
They're missable.
- clear mission bonus objective [missable]
  - money
  - reputation
  - MOM unlocks
  - if not completed, you have to reload an earlier save and retry

RA has leaderboards for these, which we can turn into checks for them.
- clear challenge
  - money

RA has counter achievements for these, the code is incredibly gnarly but I can
probably figure it out.
If I can get it from lua that would probably be more readable, but also, there's
like 250 of them, which is a pretty big constant table...
- find collectable [is check]
  - money per
  - reputation per
  - cheats at certain thresholds
  - MOM unlocks at certain thresholds
  - money at certain thresholds
  - might make each collectable a specific check, or might be easier to just
    count all collectables and unlock progressive checks

All cards are tracked in memory, RA has the addresses as alt conditions for the
"capture cards" achievements. These are spaced 0x28 bytes apart so it seems
likely that what we have here are arrays of card_t.
The status field for each card is a uint32_t and is 1 for "at large", 2 for "killed"
and 3 for "captured". 3 is set as soon as you get the mission complete popup, it
looks like; you only get the 2 next time you open the PDA.
- verify number card [missable]
  - money
  - intel
  - any that you haven't gotten before verifying the Ace will vanish when the
    Ace mission is completed
- verify face card
  - money
  - intel
  - MOM unlocks
  - always part of a mission
- verify Ace
  - money
  - intel
  - MOM unlocks
  - always part of a mission
  - this is a point of no return that vanishes all number cards of the same suit
    and spawns the next suit


Ideas for items in the pool:
- MOM unlocks (are these in lua? need to unlock MOM ingame to check)
  - maybe have cheats as separate pool items
- intel (hard -- where the fuck is this stored?)
- money (where is this???)
  - think I've found it: 1A77560; might also need to update 558BF0 or 558BF4 when wiggling it
  - might be dynamically allocated though :(
  - found it by verifying a card so that Player_UpdateMoney() gets called, then stepping
    through and watching the FPU registers until they converged on the final result, then
    jumping ahead dozens of instructions at a time while searching memory for that value
  - this is a float!
- reputation
  - RA has achievements for this (max/min reputation with all factions) that we can use

Intel and MOM unlocks are our main gating functions. You can't take on an Ace until
you both have enough intel and have completed enough prerequisite missions, so if
we can grant intel via AP instead of in-game we can control when the Ace mission unlocks.

MOM unlocks are mostly nice-to-haves but we probably want to mark a few useful ones
as progression, so that the player isn't thrown into later missions with no support.
Either specific unlocks or a general count.

Generally speaking, challenges only reward money, cards reward money and intel,
missions and collectables reward money and MoM unlocks.

Certain cards can only be verified during a mission, and unlocking some of those
missions requires collecting sufficient intel.

Unlocks from collectibles are generally given at certain thresholds, e.g. you get
unlocks at 1, 5, and 10 blueprints, but 2-4 and 6-9 give you nothing.

This suggests our check and item pools.
Checks are: collectibles, mission completion, mission bonus completion, and verification.
Items are: MoM unlocks, money, intel, and maybe collectibles.

For collectibles, we have two ways of handling them -- one is that the collectibles
are in the pool, and finding them gets you either additional checks or MoM unlocks
once you reach the threshold points.

The other option is that we remove collectables entirely, and the things they would
normally unlock are added to the pool directly, and we generate filler like free
airstrikes or additional money to make up the difference (since there's about 250
collectibles which, between them, unlike about 30 MoM entries, half of those cheat
codes rather than actual items).

For implementation, I need to do a bunch of reverse engineering.

The game, broadly speaking, has "primary" information:
- which collectibles are found;
- which missions and bonus objectives are complete;
- which challenges are complete;
- which cards are verified
- how much money you have

And secondary information, which can be derived from first principles from the
primary info:
- how many collectables you have;
- which items are available in the MoM;
- how much intel you have;
- which cards are present in the world;
- which card missions are available.

My hope is that the secondary information is stored in RAM and updated when the
primaries change, rather than being recalculated from scratch every time you open
the PDA or similar. In that case, we can watch the RAM for the primary info to
figure out what the player has accomplished and send checks, and write the ram
for the secondary info to control what is actually unlocked.


PCSX2 supports the PINE remote debugging protocol.
Socket is created in $XDG_RUNTIME_DIR/pcsx2.sock.<slot> on linux, /tmp if XDGRTD is unset
OSX uses $TMPDIR/pcsx2.sock.<slot> with TMPDIR defaulting to /tmp
The .slot may be omitted if the default slot is used
Windows uses TCP ports, slot == port number

Messages are in LTV format, little-endian.

L is a uint32_t and includes the size of the L and T fields.
T is a uint8_t.

Opcodes we care about are:
0,1,2,3: read an 8,16,32,64-bit value, V is uint32_t address
4,5,6,7: write, V is uint32_t address followed by uint{8,16,32,64}_t value
Possibly also 9 (save state) and $A (load state), argument is a uint8_t for the state slot
$B, $C, $D, $E, and $F may be useful for safety checks:
- game title
- game id
- game uuid
- game version
- emulator status (either 0 running, 1 paused, 2 shutdown)
These all return strings in the form of:
- 32-bit size including the null terminator
- null terminated string

Responses are also LTV, T is either $00 (success) or $FF (fail)
V depends on the message, for reads it's the value read, for writes or saves/loads it's empty

Batch messages consist of a single L field, followed by a series of (T,V) pairs
Responses consist of L, one T for the entire batch, then all Vs concatenated

Mercs uses Lua 5.0.1 internally. Source code is stored, compressed, in the DSK files.
It is (I think) loaded, decompressed, and compiled at game startup, the bytecode
retained and the source discarded.

Layout of a lua object (lua_TObject):
{
  int tt;  // tag: nil bool luserdata number string table function fuserdata thread
  Value union {
    int b; // if boolean
    lua_Number n; // if number -- what type is this on the PS2?
    void *p; // luserdata?
    GCObject *gc; // collectable objects
  }
}

A GCObject is
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};

// this is the "header for the string table"
// accessed with
#define getstr(ts)	cast(const char *, (ts) + 1)
// so an actual string has an implicit 'char str_data[]' at the end
typedef union TString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  struct {
    CommonHeader;
    lu_byte reserved;
    lu_hash hash;
    size_t len;
  } tsv;
} TString;

// so in memory it looks something like:
{
  void*;
  byte; // always 4, LUA_TSTRING
  byte; // 0 or 1
  byte; // always 0
  hash; // 4 bytes?
  size; // 4 bytes on MIPS I think
  actual string data, null terminated
}

#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked

typedef struct Node {
  TObject i_key;
  TObject i_val;
  struct Node *next;  /* for chaining */
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of `node' array */
  struct Table *metatable;
  TObject *array;  /* array part */
  Node *node;
  Node *firstfree;  /* this position is free; all positions after it are full */
  GCObject *gclist;
  int sizearray;  /* size of `array' array */
} Table;


00578594 - ID of current mission. Doesn't seem to be a memory address.
00579468 - mission phase counter? RA checks for this to be 3 to count a mission as complete.

00558BF0
00558BF4 - used for the cash display on the HUD. Not, however, the actual cash in inventory!

005007f4 - pointer to character info? RA derefs this and then adds 0x74 to get model index
004a4cac - cheat flag or maybe saveload flag? most RAs are configured to reset when this is nonzero


; fulfill first three SK missions in the south province
N:0xX005131e0=1
  _I:0xX00501a44_O:0xX00000010=1
  _O:0xX00558c8c=999
  _O:0xX00558c8c=3000
  _O:0xX00558c8c=50
  _P:0xX005153f0=1.1.
S
B:1  ; accumulator to -1
  _I:0x 005029be   ; read index from uint16_t
  _M:0xL00da38c0=3 ; read memory + index, sub 1, compare to 3 -- looks like $00da38c0's lower nybble is "index of next SK mission"
_B:1
  _I:0x 005029be
  _d0xL00da38c0=2
_O:0xX004a40e8=1400005746
  _Q:0xX004a40e8=1634886770
_Q:0x 005029be>0
_0xX00578594=3326808767
_I:0x 005029be_Q:0xL00da38c0<=4
S
0xX00578594=3326808767
_d0xX00579468!=3_0xX00579468=3


1A77560 -- player money (is this stable across runs?) in savestate 5. This is a float!

DA38C0 -- I think this is the scribmem block, but writing something to it
rewrites the whole fucking thing :<
504c90 holds a pointer to it

writing a string to scribmem
looks like it gets a useful pointer to $501c88 in s2
Adds $1008 to get $502c90 in a1
then does
  sll v0,v0,1

function fOdfSold()
  local n = 15
  if tMafiaShop[_shop_iCurrentItem].template then
    Shop_UnlockItem(tMafiaShop[_shop_iCurrentItem].template)
    AddTooltip {
      sMessage = '[green]' .. Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc) .. ' added to shop';
      nDisplayDuration = 6
    }
  else
    n = 30
  end

  _shop_iCurrentItem += 1
  Utility_WriteNumberToScribbleMemory('iCurrentShopItem', _shop_iCurrentItem)
  Faction_ModifyRelation('mafia', 'prokat', n)

  if tMafiaShop[_shop_iCurrentItem] then
    hOdfSold = Event_OdfSold('fOdfSold', 'b', tMafiaShop[_shop_iCurrentItem].odf)
    r1: Utility_GetStringById(tMafiaShop[_shop_iCurrentItem].desc)
    r2: Utility_GetStringById('faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorFactionName', 'faction.' .. tMafiaShop[_shop_iCurrentItem].faction)
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', tMafiaShop[_shop_iCurrentItem].desc)
  else
    Utility_WriteStringToScribbleMemory('ShopWantedActorTemplateName', nil)
    fShopkeeperKilled()

function fShopkeeperKilled()
  Ui_RemoveDisplayMarkerActor('mafia_shopkeeper')
  Actor_EnableScriptedUse('mafia_shopkeeper', false, 'actions.talk', false)
  hActorUsed = Event_CancelEvent(hActorUsed)
  hOdfSold = Event_CancelEvent(hOdfSold)


To inject a debug logger, we replace util_PrintDebugMsg and Debug_Printf
  [Node$01A8214C] 'util_PrintDebugMsg' [h=A2961C17,$00A12000]: function$009A2BC0 'util_PrintDebugMsg' [h=A2961C17,$00A12000]
    CONST$00960990 'bDebugOutput' [h=2660F98C,$009A6CC0]
    CONST$00960998 'Debug_Printf' [h=445430CF,$0098B6A0]
    CODE $009974E0
         0 01000005 GETGLOBAL r1 := _G['bDebugOutput' [h=2660F98C,$009A6CC0]]
         1 01008018      TEST not r1: r1 := r1 ; or skip
         2 00800094       JMP +3 ; 6
         3 01000045 GETGLOBAL r1 := _G['Debug_Printf' [h=445430CF,$0098B6A0]]
         4 02000000      MOVE r2 := r0
         5 01010059      CALL r1 (1 args) => 0 results
         6 0000801B    RETURN r0 ... r-1

replace constant 0 ('bDebugOutput') with 'sDebugBuffer'
replace constant 1 ('Debug_Printf') with '------------'
Replace code segment with:

  GETGLOBAL r1, 'sDebugBuffer'
  MOVE r2 := r0
  CONCAT r1, r1 .. r2
  SETGLOBAL r1, 'sDebugBuffer'
  MOVE r0, r0
  MOVE r0, r0
  RETURN

Problem: this fails if sDebugBuffer is nil, since you can't concat nil and string
The traditional solution to this is a test-and-set, but the implementation of test
assumes the instruction after it is always a jump, and will crash the VM if it's not

Might be able to replace the code segment of table_debug instead, that's a table
prettyprinter and gives me 84 instructions to work with.

In that case, I can ultimately replace it with something that, every time a debug
message is logged, instead updates a data structure in memory with information
about which things have been checked, using Utility_ReadFooFromScribbleMemory.


gameflow_AttemptAceMissionUnlock
Debug_EnableDebugMenu
Utility_GetStringById
Debug_Break
bDebugOutput
            Debug_Printf


MOM unlocks are stored at $51EE7C.
Each one is a struct with the following format:
struct {
  uint32_t id;
  uint32_t price;  // in dollars
  uint32_t new;    // 1 if the "new!" flag should appear in the shop
}

The price given is the *baseline* price; it may be increased or decreased in
practice based on your reputation with the mafia.

Entries can appear in any order depending on when you unlock things.
ID  Price         Name
06  50,000        Surgical Strike
21  25,000        S. Korean K1025 Scout
29  20,000        Mafia Technical (MG)

ID      Price  Name
 0     35,000  Mafia SUV
 1     30,000  H3
 2    200,000  Air Superiority
 3    250,000  Tank Buster
 4    300,000  Cruise Missile Strike
 5     45,000  Stealth Fighter Attack
 6     50,000  Surgical Strike
 7     75,000  Gunship Support
 8    150,000  Gunship Support II
 9    225,000  Gunship Support III
 A     75,000  Strategic Missile Strike
 B    350,000  Bunker Buster Bomb
 C     50,000  Artillery Strike
 D    100,000  Artillery Barrage
 E    200,000  Artillery Bombardment
 F     65,000  Cluster Bomb
10    500,000  Carpet Bomb
11      8,000  Covert Supply Drop
12      6,500  Allies Supply Drop
13     12,000  Special Weapons Drop
14      6,000  Chinese Supply Drop
15      2,500  Medical Supply Drop
16      7,500  North Korean Supply Drop
17      4,000  Russian Supply Drop
18     15,000  Heavy Weapons Drop
19     40,000  N. Korean BRDM Scout
1A     75,000  N. Korean BMP APC
1B     25,000  N. Korean BTR APC
1C     12,000  N. Korean Sungri Scout
1D      5,000  Civilian Car
1E     65,000  Allies UH-60
1F     95,000  Mafia MD-530
20     35,000  S. Korean K966 Scout
21     25,000  S. Korean K1025 Scout
22     60,000  S. Korean K200 APC
23     40,000  Allied M1126 APC
24     10,000  Baggage Car
25     15,000  Chinese BJ2020 Scout
26     50,000  Chinese Type 89 APC
27     25,000  Allied M1025 Scout
28     30,000  Mafia Technical (AT)
29     20,000  Mafia Technical (MG)
2A     35,000  Mafia Technical (GL)
2B     12,000  Sniper Supply Drop
2C      8,000  Vehicle Ammo Drop
2D     13,000  Vehicle Repair Drop
2E     65,000  N. Korean ZSU-57 Anti-Air
2F     20,000  Press Truck
30     35,000  Allied M1027 Anti-Air
31     10,000  N. Korean Transport
32     25,000  Civilian Street Racer
33    100,000  Chinese Type 95 Anti-Air
34    450,000  Fuel-Air Bomb
35    115,000  N. Korean MD-500
36     35,000  Mafia VIP Car
37     20,000  Chinese Fuel Truck
38     30,000  Vehicle Support Drop
39     15,000  Sniper Rifle Drop
3A     18,000  Anti-Air Rocket Drop
3B     18,000  Anti-Tank Rocket Drop
3C     20,000  Advanced Weapons Drop
3D  1,000,000  Cheat Weapons Drop
3E      8,000  Demolitions Supply Drop

$51F47C contains additional information:
struct {
  uint32_t total_unlocked;  // entries in the unlock array >= this index are ignored
  uint32_t vehicles_unlocked; // These three are cosmetic only, used for drawing the scrollbar
  uint32_t supplies_unlocked;
  uint32_t airstrikes_unlocked;
  uint32_t last_selected; // index into the unlock array of the currently focused item
}


Intel!
GetCardIntelValue returns:
- the number for number cards (so they are worth 2..10 intel points, for a total of 54)
- iFaceIntel (30) for face cards
- iAceIntel (0) for aces
iTargetIntel is set to 80
iMaxIntel is set to 34, but doesn't seem to be used.
Assuming these numbers don't change for later chapters.

I can set iTargetIntel to anything and it will appear to work, but is only checked
when I actually verify a card.

I could perhaps rig the debug logger to call `gameflow_AttemptAceMissionUnlock()` instead.
`gameflow_GetIntelTotal` is also written in lua and can thus be replaced.